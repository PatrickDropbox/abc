package go_template

template ParseFunc{
    ParseFuncName   string
    LexerType       string
    ReducerType     string
    ErrHandlerType  string

    StateIdType     string
    SymbolType      string

    StackItemType   string
    StackType       string
    SymbolStackType string

    ActionTable     string

    AcceptAction    string
    ShiftAction     string
    ReduceAction    string
}

%%
func $ParseFuncName(
    lexer $LexerType,
    reducer $ReducerType,
    errHandler $ErrHandlerType,
    startState $StateIdType) (
    *$StackItemType,
    error) {

    stateStack := $StackType{
        // Note: we don't have to populate the start symbol since its value
        // is never accessed.
        &$StackItemType{startState, nil},
    }

    symbolStack := &$SymbolStackType{lexer: lexer}

    for {
        nextSymbol, err := symbolStack.Top()
        if err != nil {
            return nil, err
        }

        action, ok := $ActionTable.Get(
            stateStack[len(stateStack)-1].StateId,
            nextSymbol.Id())
        if !ok {
            return nil, errHandler.Error(nextSymbol, stateStack)
        }

        if action.ActionType == $ShiftAction {
            stateStack = append(stateStack, action.ShiftItem(nextSymbol))

            _, err = symbolStack.Pop()
            if err != nil {
                return nil, err
            }
        } else if action.ActionType == $ReduceAction {
            var reduceSymbol *$SymbolType
            stateStack, reduceSymbol, err = action.ReduceSymbol(
                reducer,
                stateStack)
            if err != nil {
                return nil, err
            }

            symbolStack.Push(reduceSymbol)
        } else if action.ActionType == $AcceptAction {
            if len(stateStack) != 2 {
                panic("This should never happen")
            }
            return stateStack[1], nil
        } else {
            panic("Unknown action type: " + action.ActionType.String())
        }
    }
}
